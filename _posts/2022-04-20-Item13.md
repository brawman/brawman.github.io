---
title: "clone 재정의는 주의해서 진행하라"
date: 2022-04-20
categories:
  - effective java
tags:
  - java
---

# Item 13. clone 재정의는 주의해서 진행하라

객체를 복사할 수 있는 방법으로 Object클래스는 clone 메소드를 제공하고 있다. 이 메소드를 사용하기 위해서 주의해야할 부분들에 대해서 살펴보려고 한다. 또한, 객체를 복사할때 clone보다 더 좋은 방법에 대해서도 알아보도록 하자.

## Cloneable 인터페이스와 clone 메소드의 관계

- Cloneable은 복제할 수 있는 클래스임을 명시하는 **믹스인 인터페이스** 이다. 하지만 복제를 위한 어떤 메소드도 정의하고 있지 않다. (* 믹스인 인터페이스는 기존 클래스의 주된 기능에 새로운 선택적 기능을 부여)
- 복제를 위한 clone 메소드는 Object에 protected로 선언되어 있다. 이 clone 메소드는 Coneable의 구현 유무에 따라서 동작이 바뀐다. Cloneable을 구현하면 복사한 객체를 반환하며 그렇지 않으면 CloneNotSupportedException을 던진다.
- 외부에서 clone 메소드를 접근하기 위해서는 public으로 오버라이딩해야 한다.

```
// Cloneable 인터페이스를 구현
public class PhoneNumber implements Cloneable{
   // Object의 Clone메소드를 public으로 오버라이딩
   @Override
   public PhoneNumber clone() {
   		try {
      	return (PhoneNumber)super.clone();
     	} catch(CloneNotSupportedException e) {
     	...
     	}
   }
}
```

Cloneable을 구현한 클래스에서 clone 메소드를 사용하기 위해서는 이런 이례적이며 일반적이지 않은 방법은 준수해야 한다.

## clone의 명세는 강제력이 없다

### clone 명세

> x.clone() != x // 서로 다른 객체
>
> x.clone().getClass() == x.getClass() // 동일한 클래스를 참조 
>
> x.clone().equals(x) // 동치 관계

* 일반적으로 위 식들에 대해서 결과는 참(True)입니다. 하지만 반드시 만족해야하는 것은 아닙니다.
* 관례상 clone으로 반환되는 객체는 super.clone을 호출해서 얻음. x클래스와 x클래스의 모든 상위 클래스(Object제외)에서 이 관례를 따른다면 x.clone.getClass() == x.getClone()은 참.
* 관례상 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하기 위해서 super.clone으로 얻은 객체의 필드 중 하나를 수정해야할 수도 있다. ( e.g. 가변 필드)

### 상속시 발생할 수 있는 문제 상황

```
public class A {
   @Override
   public A clone() {
      return new A(...); // 컴파일러는 경고를 하지 않는다!!
   }
}

public class B extends A {
	@Override
	public B clone() {
		return (B)super.clone(); // A가 생성되었다.
	}
}
```

clone 메소드가 super.clone이 아닌 생성자를 통한 객체를 반환하면 하위 클래스에서 문제가 될 수 있다.(다운캐스팅으로 인한 런타임에러)

## 제대로 동작하는 clone 메소드

- 모든 필드가 기본 타입 or 불변 객체를 참조하면 super.clone을 통해서 객체의 복제본을 얻을 수 있다.

  >쓸데없는 복사를 지양하기 위해 불변 클래스는 clone 메소드를 제공하지 않는게 좋다.

- Super.clone에서 얻은 객체를 반환하기 전에 자신의 클래스로 형변환한다. 이렇게 함으로 클라이언트가 형변환하지 않아도 된다.

  > 자바는 공변 반환 타이핑을 지원한다(since java 1.5). 메소드 오버라이딩시 리턴타입을 원본 메소드 리턴타입의 Subclass로 오버라이딩 가능

- 검사 예외인 CloneNotSupportedException에 대해서 처리한다. 자세한 내용은 Item 71에서 ... (사실은 비검사 예외였어야 했다.)

```
@Override public PhoneNumber clone() {
	try {
		return (PhoneNumber) super.clone();
	} catch (CloneNotSupportedException e) {
		throw new AssertionError(); // 일어날 수 없는 일이다.
	}
}
```

> 가변 상태를 참조하지 않는 클래스용 clone 메소드

## 가변 필드를 가지고 있다면...

### 클래스의 필드에 배열이 있을 경우

```
public class Stack implements Cloneable {
   private Object[] elements; // 가변 필드
   private int size = 0;
   private static final int DEFAULT_INITIAL_CAPACITY = 16;

   public Stack() {
      this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
   }

   public void push(Object e) {
      ensureCapacity();
      elements[size++] = e;
   }

   public Object pop() {
      if (size == 0)
         throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null; // Eliminate obsolete reference
      return result;
   }

   public boolean isEmpty() {
      return size == 0;
   }

   @Override
   public Stack clone() {
      try {
         Stack result = (Stack)super.clone();
         result.elements = elements.clone(); // 새로운 배열 생성
         return result;
      } catch (CloneNotSupportedException e) {
         throw new AssertionError();
      }
   }

   private void ensureCapacity() {
      if (elements.length == size)
         elements = Arrays.copyOf(elements, 2 * size + 1);
   }
}
```

- elements 배열의 clone 메소드를 재귀적으로 호출해서 각각 다른 배열을 가질 수 있다. 이를 통해 elements 공유로 불변식을 해칠 수 있는 문제가 해결한다.

  > 배열은 clone 기능을 제대로 사용한 유일한 예

- super.clone을 통해 복제본이 생성된 후 elemnts 배열의 clone 호출로 새로운  값을 할당하기 위해서 final 한정자를 제거해야 한다.

### 재귀적으로 clone을 호출해서 해결하지 못할 경우

```
public class HashTable implements Cloneable {
   private Entry[] buckets = ...; // 복잡한 가변 필드

   private static class Entry {
      final Object key;
      Object value;
      Entry next;

      Entry(Object key, Object value, Entry next) {
         this.key = key;
         this.value = value;
         this.next = next;
      }

      //재귀
      Entry deepCopy() {
         return new Entry(key, value, next == null ? null : next.deepCopy());
      }
      //반복문
      // Entry deepCopy() {
      //     Entry result = new Entry(key, value, next);
      //     for(Entry p = result; p.next != null; p = p.next) {
      //        p.next = new Entry(p.next.key, p.next.value, p.next.next);
      //     }
      //     return result;
      // }
   }
   @Override
   public HashTable clone() throws CloneNotSupportedException {
      try {
         HashTable result = (HashTable)super.clone();
         result.buckets = new Entry[buckets.length];
         for (int i = 0; i < buckets.length; i++) {
            if(buckets[i] != null) {
               result.buckets[i] = buckets[i].deepCopy();
            }
         }
         return result;
      } catch ( CloneNotSupportedException e) {
         throw new AssertionError();
      }
   }
}
```

링크드리스트의 집합인 buckets는 clone을 통해서 각 링크드리스트들의 복사본을 만들 수 없다. 직접 deepCopy가 가능한 메소드를 만들어줘야하는데 재귀를 이용할 경우 리스트의 길이에 따라서 스택 오버플로가 발생할 수 있다. 이를 방지하기 위해서는 반복문을 통해서 링크드리스트 전체 노드를 복사해주는 것이 좋음.

### 고수준 api 사용해서 복사

새로운 bukets 배열을 생성하고 원본 bukets의 모든 데이터를 put(key, value) 메소드를 통해서 동일하게 만들 수 있다.

하지만 필드 단위 객체 복사를 우회하기 때문에 Cloneable 아키텍처와 어울리지 않고 저수준에서 처리할 때보다 느릴 수 있다.

## 기타 고려 사항

### 재정의될 수 있는 메서드를 호출하면 안됨

- clone 메소드에서 하위 클래스에서 재정의 할 수 있는 메소드를 호출하면 안된다. 하위 클래스의 복제 과정에서 자신의 상태를 교정할 기회를 읽고 원본과 복제본의 상태가 달리질 수 있다. (의도되지 않은 상태, 오작동)

### CloneNotSupprotedException 처리

- Clone을 재정의한 메서드에서는 사용하는 쪽의 편의를 위해서 CloneNotSupprotedException를 던지지 않아야된다. 

### 상속해서 쓰기 위한 클래스에서 clone

- 상속용 클래스는 Cloneable을 구현해서는 안된다.

- 2가지 구체적 구현 방법

  - Object와 같이 제대로 동작하는 clone 메소드를 구현하고 protected로 두고 CloneNotSupportedException도 던질 수 있도록 구현. 하위 클래스에서 선택할 수 있도록 한다.

  ```
  @Override
  protected final Object clone() throws CloneNotSuppotedException {
  	return super.clone();
  }
  ```
  
  
  
  - clone 메소드를 동작하지 않게 구현하고 하위 클래스에서 재정의하지 못하도록 한다.
  
  ```
  @Override
  protected final Object clone() throws CloneNotSuppotedException {
  	throw new CloneNotSuppotedException();
  }
  ```
  
  

### 쓰레드 동기화

- Object의 clone 메소드는 동기화를 신경 쓰지 않았다. clone 메소드를 오버라이딩 할 때 동기화에 대해서도 고려해야 한다.

## 더 좋은 방법

이미 클론 사용중인게 아니라면 복사생성자와 복사팩토리를 사용하자

- Cloneable을 이미 구현한 클래스를 확장하는게 아니라면 복사 생성자와 복사 팩토리가 더 나은 객체 복사 방식을 제공한다.

- 생성자를 통해서 객체를 생성하며 클래스의 필드에 final을 사용하는데 제약이 없고 불필요한 CloneNotSupportedException 예외를 처리하지 않아도 된다.

- 인터페이스 타입의 인스턴스를 인수로 받아서 객체를 생성할 수 있다.

  ```
  HashSet<T> s = ...;
  TreeSet<T> t = new TreeSet<>(s);
  ```
