---
title: "이왕이면 제네릭 타입으로 만들라"
date: 2022-06-26
categories:
  - effective java
tags:
  - java, 글또
---

# Item 29. 이왕이면 제네릭 타입으로 만들라

## 일반 Object 기반 스택을 제네릭 스택으로...

### 일반 Object 기반 스택

```
public class Stack {
   private Object[] elements;
   private int size = 0;
   private static final int DEFAULT_INITIAL_CAPACITY = 16;

   public Stack() {
      elements = new Object[DEFAULT_INITIAL_CAPACITY];
   }

   public void push(Object e) {
      ensureCapacity();
      elements[size++] = e;
   }

   public Object pop() {
      if (size == 0)
         throw new EmptyStackException();
      Object result = elements[--size];
      elements[size] = null;
      return result;
   }

   private void ensureCapacity() {
      if (elements.length == size)
         elements = Arrays.copyOf(elements, 2 * size);
   }
}
```

- Object 기반 스택은 클라이언트가 스택에서 꺼낸 **객체를 형변환**해야 하는데, 이때 **런타임 오류**가 날 위험이 있다.

- 제네릭으로 바꾼다고 해도 Object버전을 하용하던 클라이언트에 아무런 해가 없다.(로타입을 통한 하위 호환성 지원)

### 제네릭 스택 변환 - 컴파일 불가

```
public class Stack2<E> {
   private E[] elements;
   private int size = 0;
   private static final int DEFAULT_INITIAL_CAPACITY = 16;

   public Stack2() {
      elements = new E[DEFAULT_INITIAL_CAPACITY]; // 컴파일 에러 발생!
   }

   public void push(E e) {
      ensureCapacity();
      elements[size++] = e;
   }

   public E pop() {
      if (size == 0)
         throw new EmptyStackException();
      E result = elements[--size];
      elements[size] = null;
      return result;
   }

   ... // isEmpty와 ensureCapacity 메서드는 그대로다.
}
```

- 컬렉션 원소의 타입은 보통 **E**를 사용한다.(item 68)
- E와 같은 **실체화 불가 타입**으로는 배열을 만들 수 없어서 **컴파일 에러**가 발생한다.

### 해결1. Object 배열 사용

```
@SuppressWarnings("unchecked")
public MyStack() {
   elements = (E[])new Object[DEFAULT_INITIAL_CAPACITY];
}
```

- Object배열을 생성한 다음 제네릭 배열로 형변환해서 컴파일 오류를 해결한다.
- elements가 private필드이며 외부로 전달되지 않고 오직 push 메소드를 통해서만 원소가 추가되기 때문에 추가되는 원소가 항상 E다. 따라서 이 비검사 형변환은 안전하다.
- @SuppressWarnings 애너테이션으로 경고 메시지를 숨긴다.

### 해결2. elements 필드의 타입을 E[]에서 Object[]로 변경

```
private Object[] elements;
...
public E pop() {
   if (size == 0)
      throw new EmptyStackException();
   // push에서 E 타입만 허용하므로 이 형변환은 안전하다.
   @SuppressWarnings("unchecked") E result = (E) elements[--size];
   elements[size] = null;
   return result;
}
```

- elements필드의 타입을 E[]에서 Object[]로 변경해서 컴파일 오류를 해결한다.
- 마찬가지로 비검사 형변환이 안전한지 스스로 점검하고 @SuppressWarnings 애너테이션으로 경고 메시지를 숨긴다.

### 해결1, 해결2 비교

- 해결1이 더 **가독성**이 좋다
  - 배열의 타입을 E[]로 선언해서 오직 E타입만 받음을 어필
  - 코드가 더 짧다.
  - 배열 생성시만 형변환을 해주면 된다.
- 해결2는 배열에서 **원소를 읽을 때마다 형변환**을 해줘야 한다.
- 해결1은 E가 Object가 아닌 한 **런타임 타입이 컴파일 타입과 달라 힙 오염(heap pollution)**을 일으킬 수 있다.(Item 32)

## 더 알아보기

- 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다.
- Hashmap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
- 타입 매개변수로 int, double과 같은 **기본 타입은 사용할 수 없다**. 박싱된 기본 타입을 사용해 우회할 수 있다.
- <E extends Delayed>와 같이 한정적 타입 매개변수를 통해 Delayed 또는 Delayed의 하위 타입만 받도록 지정할 수 있다.

## 핵심

- 클라이언트에서 직접 형변환해야 하는 타입보다 **제네릭 타입이 더 안전하고 쓰기 편하다.**

- 기존 타입 중 제네릭이어야 하는게 있다면 제네릭으로 변경하자.

- 기존 클라이언트에는 아무 영향을 주지 않으면서 새로운 사용자를 훨씬 편하게 해주는 길이다.
