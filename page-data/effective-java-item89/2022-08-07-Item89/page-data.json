{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective-java-item89/2022-08-07-Item89/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라</h1>\n<h2>싱글턴 인스턴스에 대한 직렬화</h2>\n<ul>\n<li>\n<p>어떤 클래스에 Implements Serialization를 추가하면 아래와 같은 방법을 제공하더라도 싱글턴을 유지할 수 없다.</p>\n<ul>\n<li>기본 직렬화를 사용하지 않는다(Item 87)</li>\n<li>명시적인 readObject를 제공한다(Item 88)</li>\n</ul>\n</li>\n<li>\n<p>readObject를 통해서 역직렬화할때 클래스 초기화시 만들어진 인스턴스와 별개로 인스턴스가 생성되기 때문이다.</p>\n</li>\n<li>\n<p>readResolve 메서드를 제공함으로써 싱글턴을 유지할 수 있다.</p>\n<ul>\n<li>\n<p>readResolve를 구현함으로써 역직렬화 과정에서 만들어진 인스턴스 대신 readResolve 메소드에서 반환하는 인스턴스로 대체할 수 있다.</p>\n</li>\n<li>\n<p>역직렬화 과정에서 생성된 인스턴스는 가비지 컬렉션 대상이 된다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Elvis {\r\n    public static final Elvis INSTANCE = new Elvis();\r\n\r\n    private Elvis() { ...}\r\n\r\n    public void leaveTheBuilding() { ...}\r\n    \r\n    private Object readResolve(){return INSTANCE;}\r\n}</code></pre></div>\n<h2>역직렬화 과정에서 발생할 수 있는 취약점</h2>\n<ul>\n<li>객체 참조 타입 인스턴스 필드를 모두 transient로 선언하지 않는다면 역직렬화 과정에서 취약점이 발생할 수 있다.</li>\n</ul>\n<h3>참조 필드에 transient를 사용하지 않는 경우</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Elvis implements Serializable {\r\n    public static final Elvis INSTANCE = new Elvis();\r\n    private Elvis() {}\r\n    \r\n    // transient를 사용하지 않은 필드\r\n    private String[] favoriteSongs = { \"Hound Dog\", \"HeartBreak Hotel\"};\r\n    public void printFavorites() {\r\n        System.out.println(Arrays.toString(favoriteSongs));\r\n    }\r\n    \r\n    private Object readResolve() {\r\n        return INSTANCE;\r\n    }\r\n}</code></pre></div>\n<h3>도둑 클래스</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class ElvisStealer implements Serializable {\r\n\r\n    static Elvis impersonator;\r\n    private Elvis payload;\r\n\r\n    private Object readResolve() {\r\n        // 역직렬화 도중의 Elvis를 저장한다.\r\n        impersonator = payload;\r\n        // favoriteSongs 필드에 맞는 타입의 객체를 반환한다.\r\n        return new String[] { \"A Fool Such as I\" };\r\n    }\r\n    \r\n    private static final long serialVersionUID = 0;\r\n    \r\n}</code></pre></div>\n<h3>조작된 바이트 스트림 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class ElvisImpersonator {\r\n\t// 참조 필드가 ElvisStealer로 조작된 바이트 스트림\r\n\tprivate static final byte[] serializedForm = new byte[] { (byte) 0xac,\r\n\t\t\t(byte) 0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05, 0x45, 0x6c, 0x76,\r\n\t\t\t0x69, 0x73, (byte) 0x84, (byte) 0xe6, (byte) 0x93, 0x33,\r\n\t\t\t(byte) 0xc3, (byte) 0xf4, (byte) 0x8b, 0x32, 0x02, 0x00, 0x01,\r\n\t\t\t0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65,\r\n\t\t\t0x53, 0x6f, 0x6e, 0x67, 0x73, 0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61,\r\n\t\t\t0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a,\r\n\t\t\t0x65, 0x63, 0x74, 0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45,\r\n\t\t\t0x6c, 0x76, 0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72,\r\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,\r\n\t\t\t0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x74,\r\n\t\t\t0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b, 0x78, 0x70,\r\n\t\t\t0x71, 0x00, 0x7e, 0x00, 0x02 };\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// ElvisStealer.impersonator를 초기화한 다음,\r\n\t\t// 진짜 Elvis(즉, Elvis.INSTANCE)를 반환한다.\r\n\t\tElvis elvis = (Elvis) deserialize(serializedForm);\r\n\t\tElvis impersonator = ElvisStealer.impersonator;\r\n\r\n\t\telvis.printFavorites();\r\n\t\timpersonator.printFavorites();\r\n\t}\r\n\r\n\t// 주어진 직렬화 형태(바이트 스트림)로부터 객체를 만들어 반환한다.\r\n\tprivate static Object deserialize(byte[] sf) {\r\n\t\ttry {\r\n\t\t\tInputStream is = new ByteArrayInputStream(sf);\r\n\t\t\tObjectInputStream ois = new ObjectInputStream(is);\r\n\t\t\treturn ois.readObject();\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new IllegalArgumentException(e);\r\n\t\t}\r\n\t}\r\n}</code></pre></div>\n<h3>결과</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Hound Dog, HeartBreak Hotel]\r\n[A Fool Such as I]</code></pre></div>\n<h2>안전한 싱글턴 인스턴스 보장 방법</h2>\n<ul>\n<li>열거 타입을 이용하면 선언한 상수 외의 다른 객체가 존재하지 않음을 자바가 보장해준다.</li>\n<li>단, 리플렉션 API인 AccessibleObject.setAccessible를 사용할 경우는 예외</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public enum Elvis {\r\n    INSTANCE; // 다른 객체가 존재하지 않음을 자바가 보장\r\n    private String[] favoriteSongs = {\"Hound Dog\", \"Heartbreak Hotel\"};\r\n\r\n    public void printFavorites() {\r\n        System.out.println(Arrays.toString(favoriteSongs)); \r\n    } \r\n}</code></pre></div>\n<h2>정리</h2>\n<ul>\n<li>불변식을 지키기 위해 인스턴스를 통제 해야하는 경우 열거 타입을 사용하자</li>\n<li>readResolve 메소드를 통해서 직렬화와 인스턴스 통제를 지원할 경우, 모든 참조 타입 인스턴스 필드를 transient로 선언하자</li>\n</ul>","frontmatter":{"title":"인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라","summary":"effective java 3판 Item89 인스턴스 수를 통제해야 한다면 radResolve보다는 열거 타입을 사용하라를 읽고 정리","date":"2022.08.07.","categories":["이펙티브자바","effective java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAbABQDASIAAhEBAxEB/8QAGgABAAIDAQAAAAAAAAAAAAAAAAgJAQMEB//EABUBAQEAAAAAAAAAAAAAAAAAAAUG/9oADAMBAAIQAxAAAAG5rwTTB4CpvDD8tGyEdsXaeuZIEf/EAB4QAAAGAgMAAAAAAAAAAAAAAAADBAUGBwECEBES/9oACAEBAAEFApdNG6HaHXISpNF2esIWE47Z0Fjx10kKUmuZMxHhP3nTj//EACQRAAIBBAECBwAAAAAAAAAAAAECAwQFERITIVEAECIjMUFC/9oACAEDAQE/AbHbKOsal543kLze4NikZjDlNfSwY/k7Ky9crj78rfepqDg0hhlWF+RORTtknbGwOV+SOnc9znx//8QAIREAAgEEAgIDAAAAAAAAAAAAAQIDBBESIQUQIjFBUpH/2gAIAQIBAT8B5OuqadpljkRAqDHxu9yqtcEjH7as2t69dVfGx1JlykdDIMWxtbQAGiN+vn86/8QAJhAAAgEDAwQCAwEAAAAAAAAAAQIDBBESBRMhABAUIjFCIzJRcf/aAAgBAQAGPwKgk1Cnq511CWeGLxVjbBoIhK27m6WVgbBgCL/tiOeqel0jQ6s1Esi5PqTpDTCC+Jxakeok3mYjFJEQBblufXtoRBlEYqa8zbNgcEpoZPZipVUulmLWBvje7DqiYn8NSI5RHtRBsFlEq57ZJUhpMnHCkfWygDrTodMijlMUlX5Akk21MU8KJi3q4ZWK8gqfgf70k/hvJGkwAioTVV+DMBY7fj8RlU2jIpYRi18OO3JJ93+Tf7H+9//EAB0QAQACAgMBAQAAAAAAAAAAAAERIQAxEEHhUWH/2gAIAQEAAT8hQkCBPaWiaI3gwiIq7yPzGNRfFzF3ibgUAwTXTCrb46i2syOiZv3BWB06/P3+5ENF26O7KRKeNAIU9xJUd7LqJTRoNBRBz//aAAwDAQACAAMAAAAQs81w/8QAGREBAQADAQAAAAAAAAAAAAAAAREAECFB/9oACAEDAQE/ELaUq5FDao+iUrClKfJWhKNHKBjpf//EABgRAQEBAQEAAAAAAAAAAAAAAAERIQBB/9oACAECAQE/ENVXoaVF4CoDWh0+Ku3LAnRDpFCqE7//xAAeEAEAAgEEAwAAAAAAAAAAAAABABEhMYGhsRCR8P/aAAgBAQABPxBHExQUjZumD6rc21SimHktSLGfbwpLnosBPBc9txBkbGSuejSq8MYmm/ZlHN3AuzCJIcexUlzQuyCiFzBGm/ZriK+OiMGCAdDQQIAV8KdeP//Z"},"images":{"fallback":{"src":"/static/af80a83f970b5d165954e4fccc42c314/47071/icon.jpg","srcSet":"/static/af80a83f970b5d165954e4fccc42c314/d5b61/icon.jpg 224w,\n/static/af80a83f970b5d165954e4fccc42c314/70fc1/icon.jpg 447w,\n/static/af80a83f970b5d165954e4fccc42c314/47071/icon.jpg 894w","sizes":"(min-width: 894px) 894px, 100vw"},"sources":[{"srcSet":"/static/af80a83f970b5d165954e4fccc42c314/26dcb/icon.webp 224w,\n/static/af80a83f970b5d165954e4fccc42c314/95f22/icon.webp 447w,\n/static/af80a83f970b5d165954e4fccc42c314/49563/icon.webp 894w","type":"image/webp","sizes":"(min-width: 894px) 894px, 100vw"}]},"width":894,"height":1200}},"publicURL":"/static/af80a83f970b5d165954e4fccc42c314/icon.jpeg"}}}}]}},"pageContext":{"slug":"/effective-java-item89/2022-08-07-Item89/"}},"staticQueryHashes":[]}