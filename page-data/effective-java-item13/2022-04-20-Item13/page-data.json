{"componentChunkName":"component---src-templates-post-template-tsx","path":"/effective-java-item13/2022-04-20-Item13/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>Item 13. clone 재정의는 주의해서 진행하라</h1>\n<p>객체를 복사할 수 있는 방법으로 Object클래스는 clone 메소드를 제공하고 있다. 이 메소드를 사용하기 위해서 주의해야할 부분들에 대해서 살펴보려고 한다. 또한, 객체를 복사할때 clone보다 더 좋은 방법에 대해서도 알아보도록 하자.</p>\n<h2>Cloneable 인터페이스와 clone 메소드의 관계</h2>\n<ul>\n<li>Cloneable은 복제할 수 있는 클래스임을 명시하는 <strong>믹스인 인터페이스</strong> 이다. 하지만 복제를 위한 어떤 메소드도 정의하고 있지 않다. (* 믹스인 인터페이스는 기존 클래스의 주된 기능에 새로운 선택적 기능을 부여)</li>\n<li>복제를 위한 clone 메소드는 Object에 protected로 선언되어 있다. 이 clone 메소드는 Coneable의 구현 유무에 따라서 동작이 바뀐다. Cloneable을 구현하면 복사한 객체를 반환하며 그렇지 않으면 CloneNotSupportedException을 던진다.</li>\n<li>외부에서 clone 메소드를 접근하기 위해서는 public으로 오버라이딩해야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Cloneable 인터페이스를 구현\r\npublic class PhoneNumber implements Cloneable{\r\n   // Object의 Clone메소드를 public으로 오버라이딩\r\n   @Override\r\n   public PhoneNumber clone() {\r\n           try {\r\n          return (PhoneNumber)super.clone();\r\n         } catch(CloneNotSupportedException e) {\r\n         ...\r\n         }\r\n   }\r\n}</code></pre></div>\n<p>Cloneable을 구현한 클래스에서 clone 메소드를 사용하기 위해서는 이런 이례적이며 일반적이지 않은 방법은 준수해야 한다.</p>\n<h2>clone의 명세는 강제력이 없다</h2>\n<h3>clone 명세</h3>\n<blockquote>\n<p>x.clone() != x // 서로 다른 객체</p>\n<p>x.clone().getClass() == x.getClass() // 동일한 클래스를 참조</p>\n<p>x.clone().equals(x) // 동치 관계</p>\n</blockquote>\n<ul>\n<li>일반적으로 위 식들에 대해서 결과는 참(True)입니다. 하지만 반드시 만족해야하는 것은 아닙니다.</li>\n<li>관례상 clone으로 반환되는 객체는 super.clone을 호출해서 얻음. x클래스와 x클래스의 모든 상위 클래스(Object제외)에서 이 관례를 따른다면 x.clone.getClass() == x.getClone()은 참.</li>\n<li>관례상 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하기 위해서 super.clone으로 얻은 객체의 필드 중 하나를 수정해야할 수도 있다. ( e.g. 가변 필드)</li>\n</ul>\n<h3>상속시 발생할 수 있는 문제 상황</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class A {\r\n   @Override\r\n   public A clone() {\r\n      return new A(...); // 컴파일러는 경고를 하지 않는다!!\r\n   }\r\n}\r\n\r\npublic class B extends A {\r\n    @Override\r\n    public B clone() {\r\n        return (B)super.clone(); // A가 생성되었다.\r\n    }\r\n}</code></pre></div>\n<p>clone 메소드가 super.clone이 아닌 생성자를 통한 객체를 반환하면 하위 클래스에서 문제가 될 수 있다.(다운캐스팅으로 인한 런타임에러)</p>\n<h2>제대로 동작하는 clone 메소드</h2>\n<ul>\n<li>\n<p>모든 필드가 기본 타입 or 불변 객체를 참조하면 super.clone을 통해서 객체의 복제본을 얻을 수 있다.</p>\n<blockquote>\n<p>쓸데없는 복사를 지양하기 위해 불변 클래스는 clone 메소드를 제공하지 않는게 좋다.</p>\n</blockquote>\n</li>\n<li>\n<p>Super.clone에서 얻은 객체를 반환하기 전에 자신의 클래스로 형변환한다. 이렇게 함으로 클라이언트가 형변환하지 않아도 된다.</p>\n<blockquote>\n<p>자바는 공변 반환 타이핑을 지원한다(since java 1.5). 메소드 오버라이딩시 리턴타입을 원본 메소드 리턴타입의 Subclass로 오버라이딩 가능</p>\n</blockquote>\n</li>\n<li>\n<p>검사 예외인 CloneNotSupportedException에 대해서 처리한다. 자세한 내용은 Item 71에서 … (사실은 비검사 예외였어야 했다.)</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Override public PhoneNumber clone() {\r\n    try {\r\n        return (PhoneNumber) super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new AssertionError(); // 일어날 수 없는 일이다.\r\n    }\r\n}</code></pre></div>\n<blockquote>\n<p>가변 상태를 참조하지 않는 클래스용 clone 메소드</p>\n</blockquote>\n<h2>가변 필드를 가지고 있다면…</h2>\n<h3>클래스의 필드에 배열이 있을 경우</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Stack implements Cloneable {\r\n   private Object[] elements; // 가변 필드\r\n   private int size = 0;\r\n   private static final int DEFAULT_INITIAL_CAPACITY = 16;\r\n\r\n   public Stack() {\r\n      this.elements = new Object[DEFAULT_INITIAL_CAPACITY];\r\n   }\r\n\r\n   public void push(Object e) {\r\n      ensureCapacity();\r\n      elements[size++] = e;\r\n   }\r\n\r\n   public Object pop() {\r\n      if (size == 0)\r\n         throw new EmptyStackException();\r\n      Object result = elements[--size];\r\n      elements[size] = null; // Eliminate obsolete reference\r\n      return result;\r\n   }\r\n\r\n   public boolean isEmpty() {\r\n      return size == 0;\r\n   }\r\n\r\n   @Override\r\n   public Stack clone() {\r\n      try {\r\n         Stack result = (Stack)super.clone();\r\n         result.elements = elements.clone(); // 새로운 배열 생성\r\n         return result;\r\n      } catch (CloneNotSupportedException e) {\r\n         throw new AssertionError();\r\n      }\r\n   }\r\n\r\n   private void ensureCapacity() {\r\n      if (elements.length == size)\r\n         elements = Arrays.copyOf(elements, 2 * size + 1);\r\n   }\r\n}</code></pre></div>\n<ul>\n<li>\n<p>elements 배열의 clone 메소드를 재귀적으로 호출해서 각각 다른 배열을 가질 수 있다. 이를 통해 elements 공유로 불변식을 해칠 수 있는 문제가 해결한다.</p>\n<blockquote>\n<p>배열은 clone 기능을 제대로 사용한 유일한 예</p>\n</blockquote>\n</li>\n<li>\n<p>super.clone을 통해 복제본이 생성된 후 elemnts 배열의 clone 호출로 새로운  값을 할당하기 위해서 final 한정자를 제거해야 한다.</p>\n</li>\n</ul>\n<h3>재귀적으로 clone을 호출해서 해결하지 못할 경우</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class HashTable implements Cloneable {\r\n   private Entry[] buckets = ...; // 복잡한 가변 필드\r\n\r\n   private static class Entry {\r\n      final Object key;\r\n      Object value;\r\n      Entry next;\r\n\r\n      Entry(Object key, Object value, Entry next) {\r\n         this.key = key;\r\n         this.value = value;\r\n         this.next = next;\r\n      }\r\n\r\n      //재귀\r\n      Entry deepCopy() {\r\n         return new Entry(key, value, next == null ? null : next.deepCopy());\r\n      }\r\n      //반복문\r\n      // Entry deepCopy() {\r\n      //     Entry result = new Entry(key, value, next);\r\n      //     for(Entry p = result; p.next != null; p = p.next) {\r\n      //        p.next = new Entry(p.next.key, p.next.value, p.next.next);\r\n      //     }\r\n      //     return result;\r\n      // }\r\n   }\r\n   @Override\r\n   public HashTable clone() throws CloneNotSupportedException {\r\n      try {\r\n         HashTable result = (HashTable)super.clone();\r\n         result.buckets = new Entry[buckets.length];\r\n         for (int i = 0; i &lt; buckets.length; i++) {\r\n            if(buckets[i] != null) {\r\n               result.buckets[i] = buckets[i].deepCopy();\r\n            }\r\n         }\r\n         return result;\r\n      } catch ( CloneNotSupportedException e) {\r\n         throw new AssertionError();\r\n      }\r\n   }\r\n}</code></pre></div>\n<p>링크드리스트의 집합인 buckets는 clone을 통해서 각 링크드리스트들의 복사본을 만들 수 없다. 직접 deepCopy가 가능한 메소드를 만들어줘야하는데 재귀를 이용할 경우 리스트의 길이에 따라서 스택 오버플로가 발생할 수 있다. 이를 방지하기 위해서는 반복문을 통해서 링크드리스트 전체 노드를 복사해주는 것이 좋음.</p>\n<h3>고수준 api 사용해서 복사</h3>\n<p>새로운 bukets 배열을 생성하고 원본 bukets의 모든 데이터를 put(key, value) 메소드를 통해서 동일하게 만들 수 있다.</p>\n<p>하지만 필드 단위 객체 복사를 우회하기 때문에 Cloneable 아키텍처와 어울리지 않고 저수준에서 처리할 때보다 느릴 수 있다.</p>\n<h2>기타 고려 사항</h2>\n<h3>재정의될 수 있는 메서드를 호출하면 안됨</h3>\n<ul>\n<li>clone 메소드에서 하위 클래스에서 재정의 할 수 있는 메소드를 호출하면 안된다. 하위 클래스의 복제 과정에서 자신의 상태를 교정할 기회를 읽고 원본과 복제본의 상태가 달리질 수 있다. (의도되지 않은 상태, 오작동)</li>\n</ul>\n<h3>CloneNotSupprotedException 처리</h3>\n<ul>\n<li>Clone을 재정의한 메서드에서는 사용하는 쪽의 편의를 위해서 CloneNotSupprotedException를 던지지 않아야된다.</li>\n</ul>\n<h3>상속해서 쓰기 위한 클래스에서 clone</h3>\n<ul>\n<li>\n<p>상속용 클래스는 Cloneable을 구현해서는 안된다.</p>\n</li>\n<li>\n<p>2가지 구체적 구현 방법</p>\n<ul>\n<li>Object와 같이 제대로 동작하는 clone 메소드를 구현하고 protected로 두고 CloneNotSupportedException도 던질 수 있도록 구현. 하위 클래스에서 선택할 수 있도록 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Override\r\nprotected final Object clone() throws CloneNotSuppotedException {\r\n    return super.clone();\r\n}</code></pre></div>\n</li>\n<li>\n<p>clone 메소드를 동작하지 않게 구현하고 하위 클래스에서 재정의하지 못하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Override\r\nprotected final Object clone() throws CloneNotSuppotedException {\r\n  throw new CloneNotSuppotedException();\r\n}</code></pre></div>\n</li>\n</ul>\n<h3>쓰레드 동기화</h3>\n<ul>\n<li>Object의 clone 메소드는 동기화를 신경 쓰지 않았다. clone 메소드를 오버라이딩 할 때 동기화에 대해서도 고려해야 한다.</li>\n</ul>\n<h2>더 좋은 방법</h2>\n<p>이미 클론 사용중인게 아니라면 복사생성자와 복사팩토리를 사용하자</p>\n<ul>\n<li>\n<p>Cloneable을 이미 구현한 클래스를 확장하는게 아니라면 복사 생성자와 복사 팩토리가 더 나은 객체 복사 방식을 제공한다.</p>\n</li>\n<li>\n<p>생성자를 통해서 객체를 생성하며 클래스의 필드에 final을 사용하는데 제약이 없고 불필요한 CloneNotSupportedException 예외를 처리하지 않아도 된다.</p>\n</li>\n<li>\n<p>인터페이스 타입의 인스턴스를 인수로 받아서 객체를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HashSet&lt;T> s = ...;\r\nTreeSet&lt;T> t = new TreeSet&lt;>(s);</code></pre></div>\n</li>\n</ul>","frontmatter":{"title":"clone 재정의는 주의해서 진행하라","summary":"effective java 3판 Item13 clone 재정의는 주의해서 진행하라를 읽고 정리해본다.","date":"2022.04.20.","categories":["이펙티브자바","effective java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAbABQDASIAAhEBAxEB/8QAGgAAAgIDAAAAAAAAAAAAAAAAAAgBCQMEB//EABUBAQEAAAAAAAAAAAAAAAAAAAUG/9oADAMBAAIQAxAAAAG5rgmFHwKi8IB+XWxI7Yt49iCRAf8A/8QAHhAAAQMEAwAAAAAAAAAAAAAAAwUGBwABAgQQERL/2gAIAQEAAQUCdz0T2dgWZA7Jamz1bRQTFyVKkduqjh1Qxy5kI9A7vhx//8QAIxEAAgEEAQMFAAAAAAAAAAAAAQIDBAUREhMAIVEQIiMxQv/aAAgBAwEBPwGx2yjrGpeeOSQvN8g2KRmMOU19rBj+TsrL3yuD9+lvvU9BwaRQyrC/InIp2yTsRsDlc5I7eT5Oev/EAB8RAAIBBAMBAQAAAAAAAAAAAAECAwQREiEFEDFSYf/aAAgBAgEBPwHk6+pp2mWORECoMbqC2RUNcFhb61ZtC/51V8bHUmXKR0MgCtja2gANEb8HvX//xAAmEAACAQMDBAIDAQAAAAAAAAABAgMEERIFEyEAEBQiMUIjMlFx/9oACAEBAAY/AqCTUKernXUJZ4ovGWM4NBEJW3c3WysDYEAgH9sRz1T0ukaHVmolkGT6k8cNMIL4nFqV55N5mK4pIiAC5bn17aEbyiMVNeZtqwOCU0MnsSCqpdMWLWByxvdh1REn8NSI5hHtxBsFkEq57dyhDSZOOFI+tlsOtOh0yJJTFJV+QJJMFMU8KJi3q4ZWI5BU/A/3pJ/DkkjSYARURqq/BmAscNjiMhNsyKzBBa+HHbkk+7/Jv9j/AHv/AP/EABwQAQACAgMBAAAAAAAAAAAAAAERIQAxEEFR4f/aAAgBAQABPyFKAMS1peJsm8GGQB3IQd+Sqb4MrNeouD4KJNMI7xlGr6SpkdEPP7gLZ6Sfn395ENFOyPzKbOfcIdD7jSs72XUSmjQaCiDn/9oADAMBAAIAAwAAABAnzDD/xAAaEQEBAAIDAAAAAAAAAAAAAAARAQAhEDFB/9oACAEDAQE/EE0YtyIA1R8I83Lnr2uAoh3khLwP/8QAGBEBAQEBAQAAAAAAAAAAAAAAASERADH/2gAIAQIBAT8Qg6sBDsLlZFJR2/VU3hhvPQ0OEgnf/8QAHRABAAIBBQEAAAAAAAAAAAAAAQARIRAxgaGxkf/aAAgBAQABPxBrA1s8g5rkX601n/ACKMIegXM/XpSb6PmCG4KTREUN34vV7i1jcaG3PpikOZ3j1D1ITaI4oIZiiPp5WCBtz6a6lbwNDAYIB4aGBADT/9k="},"images":{"fallback":{"src":"/static/af80a83f970b5d165954e4fccc42c314/47071/icon.jpg","srcSet":"/static/af80a83f970b5d165954e4fccc42c314/d5b61/icon.jpg 224w,\n/static/af80a83f970b5d165954e4fccc42c314/70fc1/icon.jpg 447w,\n/static/af80a83f970b5d165954e4fccc42c314/47071/icon.jpg 894w","sizes":"(min-width: 894px) 894px, 100vw"},"sources":[{"srcSet":"/static/af80a83f970b5d165954e4fccc42c314/26dcb/icon.webp 224w,\n/static/af80a83f970b5d165954e4fccc42c314/95f22/icon.webp 447w,\n/static/af80a83f970b5d165954e4fccc42c314/49563/icon.webp 894w","type":"image/webp","sizes":"(min-width: 894px) 894px, 100vw"}]},"width":894,"height":1200}},"publicURL":"/static/af80a83f970b5d165954e4fccc42c314/icon.jpeg"}}}}]}},"pageContext":{"slug":"/effective-java-item13/2022-04-20-Item13/"}},"staticQueryHashes":[]}